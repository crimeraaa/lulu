/**
 * @brief   The Lulu parser is not it's own struct, but rather it is a set of
 *          functions dedicated to determining operator precedence.
 *          Code generation (i.e. emitting instructions) goes to `compiler.c`
 *          while Token manipulation goes to `lexer.c`.
 *
 *          In other words, parsing is the bridge between the tokens and the
 *          actual generated bytecode.
 */
#ifndef LULU_PARSER_H
#define LULU_PARSER_H

#include "compiler.h"
#include "lexer.h"

typedef enum {
    PREC_NONE,
    PREC_ASSIGN,     // `=`
    PREC_OR,         // `or`
    PREC_AND,        // `and`
    PREC_EQUALITY,   // `==` and `!=`
    PREC_COMPARISON, // `<`, `>`, `<=` and `>=`
    PREC_CONCAT,     // `..`
    PREC_TERMINAL,   // `+` and `-`
    PREC_FACTOR,     // `*`, `/`, `%` and `^`
    PREC_UNARY,      // `not`, `-` and `#`
    PREC_POW,        // `^`
    PREC_CALL,       // `.` `()`
    PREC_PRIMARY,
} Precedence;

typedef void (*ParseFn)(Compiler *self);

typedef struct {
    ParseFn prefixfn;
    ParseFn infixfn;
    Precedence prec;
} ParseRule;

/**
 * @note    In the book, Robert uses `parsePrecedence(PREC_ASSIGNMENT)` but
 *          doing that will allow nested assignments as in C. For Lua, we have
 *          to use 1 precedence higher to disallow them.
 */
void expression(Compiler *self);

#endif /* LULU_PARSER_H */
