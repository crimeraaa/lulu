/**
 * @brief   The Lulu parser is not it's own struct, but rather it is a set of
 *          functions dedicated to determining operator precedence.
 *          Code generation (i.e. emitting instructions) goes to `compiler.c`
 *          while Token manipulation goes to `lexer.c`.
 *
 *          In other words, parsing is the bridge between the tokens and the
 *          actual generated bytecode.
 */
#ifndef LULU_PARSER_H
#define LULU_PARSER_H

#include "compiler.h"
#include "lexer.h"

typedef enum {
    PREC_NONE,
    PREC_ASSIGN,     // `=`
    PREC_OR,         // `or`
    PREC_AND,        // `and`
    PREC_EQUALITY,   // `==` and `!=`
    PREC_COMPARISON, // `<`, `>`, `<=` and `>=`
    PREC_CONCAT,     // `..`
    PREC_TERMINAL,   // `+` and `-`
    PREC_FACTOR,     // `*`, `/`, `%` and `^`
    PREC_UNARY,      // `not`, `-` and `#`
    PREC_POW,        // `^`
    PREC_CALL,       // `.` `()`
    PREC_PRIMARY,
} Precedence;

typedef void (*ParseFn)(Compiler *cpl, Lexer *ls);

typedef const struct {
    ParseFn    prefixfn;
    ParseFn    infixfn;
    Precedence precedence;
} ParseRule;

typedef enum {
    ASSIGN_GLOBAL,
    ASSIGN_LOCAL,
    ASSIGN_TABLE,
} AssignType;

typedef struct Assignment Assignment;

struct Assignment {
    Assignment *prev;
    int         arg;
    AssignType  type;
};

/**
 * @brief   Declarations may have a stack effect/s, like pushing values from
 *          expressions to act as locals variables.
 *
 * @details declaration ::= vardecl ';'
 *                        | statement ';'
 *
 * @note    Similar to `lparser.c:chunk()`.
 */
void declaration(Compiler *cpl, Lexer *ls);

#endif /* LULU_PARSER_H */
